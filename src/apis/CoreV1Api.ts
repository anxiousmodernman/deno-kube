// tslint:disable
/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.16.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime.ts';
import {
    IoK8sApiAutoscalingV1Scale,
    IoK8sApiAutoscalingV1ScaleFromJSON,
    IoK8sApiAutoscalingV1ScaleToJSON,
    IoK8sApiCoreV1Binding,
    IoK8sApiCoreV1BindingFromJSON,
    IoK8sApiCoreV1BindingToJSON,
    IoK8sApiCoreV1ComponentStatus,
    IoK8sApiCoreV1ComponentStatusFromJSON,
    IoK8sApiCoreV1ComponentStatusToJSON,
    IoK8sApiCoreV1ComponentStatusList,
    IoK8sApiCoreV1ComponentStatusListFromJSON,
    IoK8sApiCoreV1ComponentStatusListToJSON,
    IoK8sApiCoreV1ConfigMap,
    IoK8sApiCoreV1ConfigMapFromJSON,
    IoK8sApiCoreV1ConfigMapToJSON,
    IoK8sApiCoreV1ConfigMapList,
    IoK8sApiCoreV1ConfigMapListFromJSON,
    IoK8sApiCoreV1ConfigMapListToJSON,
    IoK8sApiCoreV1Endpoints,
    IoK8sApiCoreV1EndpointsFromJSON,
    IoK8sApiCoreV1EndpointsToJSON,
    IoK8sApiCoreV1EndpointsList,
    IoK8sApiCoreV1EndpointsListFromJSON,
    IoK8sApiCoreV1EndpointsListToJSON,
    IoK8sApiCoreV1Event,
    IoK8sApiCoreV1EventFromJSON,
    IoK8sApiCoreV1EventToJSON,
    IoK8sApiCoreV1EventList,
    IoK8sApiCoreV1EventListFromJSON,
    IoK8sApiCoreV1EventListToJSON,
    IoK8sApiCoreV1LimitRange,
    IoK8sApiCoreV1LimitRangeFromJSON,
    IoK8sApiCoreV1LimitRangeToJSON,
    IoK8sApiCoreV1LimitRangeList,
    IoK8sApiCoreV1LimitRangeListFromJSON,
    IoK8sApiCoreV1LimitRangeListToJSON,
    IoK8sApiCoreV1Namespace,
    IoK8sApiCoreV1NamespaceFromJSON,
    IoK8sApiCoreV1NamespaceToJSON,
    IoK8sApiCoreV1NamespaceList,
    IoK8sApiCoreV1NamespaceListFromJSON,
    IoK8sApiCoreV1NamespaceListToJSON,
    IoK8sApiCoreV1Node,
    IoK8sApiCoreV1NodeFromJSON,
    IoK8sApiCoreV1NodeToJSON,
    IoK8sApiCoreV1NodeList,
    IoK8sApiCoreV1NodeListFromJSON,
    IoK8sApiCoreV1NodeListToJSON,
    IoK8sApiCoreV1PersistentVolume,
    IoK8sApiCoreV1PersistentVolumeFromJSON,
    IoK8sApiCoreV1PersistentVolumeToJSON,
    IoK8sApiCoreV1PersistentVolumeClaim,
    IoK8sApiCoreV1PersistentVolumeClaimFromJSON,
    IoK8sApiCoreV1PersistentVolumeClaimToJSON,
    IoK8sApiCoreV1PersistentVolumeClaimList,
    IoK8sApiCoreV1PersistentVolumeClaimListFromJSON,
    IoK8sApiCoreV1PersistentVolumeClaimListToJSON,
    IoK8sApiCoreV1PersistentVolumeList,
    IoK8sApiCoreV1PersistentVolumeListFromJSON,
    IoK8sApiCoreV1PersistentVolumeListToJSON,
    IoK8sApiCoreV1Pod,
    IoK8sApiCoreV1PodFromJSON,
    IoK8sApiCoreV1PodToJSON,
    IoK8sApiCoreV1PodList,
    IoK8sApiCoreV1PodListFromJSON,
    IoK8sApiCoreV1PodListToJSON,
    IoK8sApiCoreV1PodTemplate,
    IoK8sApiCoreV1PodTemplateFromJSON,
    IoK8sApiCoreV1PodTemplateToJSON,
    IoK8sApiCoreV1PodTemplateList,
    IoK8sApiCoreV1PodTemplateListFromJSON,
    IoK8sApiCoreV1PodTemplateListToJSON,
    IoK8sApiCoreV1ReplicationController,
    IoK8sApiCoreV1ReplicationControllerFromJSON,
    IoK8sApiCoreV1ReplicationControllerToJSON,
    IoK8sApiCoreV1ReplicationControllerList,
    IoK8sApiCoreV1ReplicationControllerListFromJSON,
    IoK8sApiCoreV1ReplicationControllerListToJSON,
    IoK8sApiCoreV1ResourceQuota,
    IoK8sApiCoreV1ResourceQuotaFromJSON,
    IoK8sApiCoreV1ResourceQuotaToJSON,
    IoK8sApiCoreV1ResourceQuotaList,
    IoK8sApiCoreV1ResourceQuotaListFromJSON,
    IoK8sApiCoreV1ResourceQuotaListToJSON,
    IoK8sApiCoreV1Secret,
    IoK8sApiCoreV1SecretFromJSON,
    IoK8sApiCoreV1SecretToJSON,
    IoK8sApiCoreV1SecretList,
    IoK8sApiCoreV1SecretListFromJSON,
    IoK8sApiCoreV1SecretListToJSON,
    IoK8sApiCoreV1Service,
    IoK8sApiCoreV1ServiceFromJSON,
    IoK8sApiCoreV1ServiceToJSON,
    IoK8sApiCoreV1ServiceAccount,
    IoK8sApiCoreV1ServiceAccountFromJSON,
    IoK8sApiCoreV1ServiceAccountToJSON,
    IoK8sApiCoreV1ServiceAccountList,
    IoK8sApiCoreV1ServiceAccountListFromJSON,
    IoK8sApiCoreV1ServiceAccountListToJSON,
    IoK8sApiCoreV1ServiceList,
    IoK8sApiCoreV1ServiceListFromJSON,
    IoK8sApiCoreV1ServiceListToJSON,
    IoK8sApiPolicyV1beta1Eviction,
    IoK8sApiPolicyV1beta1EvictionFromJSON,
    IoK8sApiPolicyV1beta1EvictionToJSON,
    IoK8sApimachineryPkgApisMetaV1APIResourceList,
    IoK8sApimachineryPkgApisMetaV1APIResourceListFromJSON,
    IoK8sApimachineryPkgApisMetaV1APIResourceListToJSON,
    IoK8sApimachineryPkgApisMetaV1DeleteOptions,
    IoK8sApimachineryPkgApisMetaV1DeleteOptionsFromJSON,
    IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON,
    IoK8sApimachineryPkgApisMetaV1Status,
    IoK8sApimachineryPkgApisMetaV1StatusFromJSON,
    IoK8sApimachineryPkgApisMetaV1StatusToJSON,
    IoK8sApimachineryPkgApisMetaV1WatchEvent,
    IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON,
    IoK8sApimachineryPkgApisMetaV1WatchEventToJSON,
} from '../models/index.ts';

export interface ConnectCoreV1DeleteNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1DeleteNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1DeleteNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1DeleteNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1GetNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1GetNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1GetNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface ConnectCoreV1GetNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1GetNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1GetNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1GetNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1GetNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1GetNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1HeadNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1HeadNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1HeadNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1HeadNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1HeadNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1OptionsNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1OptionsNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1OptionsNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1OptionsNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PatchNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PatchNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PatchNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PatchNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PatchNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PostNamespacedPodAttachRequest {
    name: string;
    namespace: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1PostNamespacedPodExecRequest {
    name: string;
    namespace: string;
    command?: string;
    container?: string;
    stderr?: boolean;
    stdin?: boolean;
    stdout?: boolean;
    tty?: boolean;
}

export interface ConnectCoreV1PostNamespacedPodPortforwardRequest {
    name: string;
    namespace: string;
    ports?: number;
}

export interface ConnectCoreV1PostNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PostNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PostNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PostNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PostNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PostNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PutNamespacedPodProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PutNamespacedPodProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PutNamespacedServiceProxyRequest {
    name: string;
    namespace: string;
    path?: string;
}

export interface ConnectCoreV1PutNamespacedServiceProxyWithPathRequest {
    name: string;
    namespace: string;
    path: string;
    path2?: string;
}

export interface ConnectCoreV1PutNodeProxyRequest {
    name: string;
    path?: string;
}

export interface ConnectCoreV1PutNodeProxyWithPathRequest {
    name: string;
    path: string;
    path2?: string;
}

export interface CreateCoreV1NamespaceRequest {
    body: IoK8sApiCoreV1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedBindingRequest {
    namespace: string;
    body: IoK8sApiCoreV1Binding;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface CreateCoreV1NamespacedConfigMapRequest {
    namespace: string;
    body: IoK8sApiCoreV1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedEndpointsRequest {
    namespace: string;
    body: IoK8sApiCoreV1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedEventRequest {
    namespace: string;
    body: IoK8sApiCoreV1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedLimitRangeRequest {
    namespace: string;
    body: IoK8sApiCoreV1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedPersistentVolumeClaimRequest {
    namespace: string;
    body: IoK8sApiCoreV1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedPodRequest {
    namespace: string;
    body: IoK8sApiCoreV1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedPodBindingRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Binding;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface CreateCoreV1NamespacedPodEvictionRequest {
    name: string;
    namespace: string;
    body: IoK8sApiPolicyV1beta1Eviction;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface CreateCoreV1NamespacedPodTemplateRequest {
    namespace: string;
    body: IoK8sApiCoreV1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedReplicationControllerRequest {
    namespace: string;
    body: IoK8sApiCoreV1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedResourceQuotaRequest {
    namespace: string;
    body: IoK8sApiCoreV1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedSecretRequest {
    namespace: string;
    body: IoK8sApiCoreV1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedServiceRequest {
    namespace: string;
    body: IoK8sApiCoreV1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NamespacedServiceAccountRequest {
    namespace: string;
    body: IoK8sApiCoreV1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1NodeRequest {
    body: IoK8sApiCoreV1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface CreateCoreV1PersistentVolumeRequest {
    body: IoK8sApiCoreV1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface DeleteCoreV1CollectionNamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedEventRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedPodRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionNodeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1CollectionPersistentVolumeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    dryRun?: string;
    fieldSelector?: string;
    gracePeriodSeconds?: number;
    labelSelector?: string;
    limit?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespaceRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1NodeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface DeleteCoreV1PersistentVolumeRequest {
    name: string;
    pretty?: string;
    dryRun?: string;
    gracePeriodSeconds?: number;
    orphanDependents?: boolean;
    propagationPolicy?: string;
    body?: IoK8sApimachineryPkgApisMetaV1DeleteOptions;
}

export interface ListCoreV1ComponentStatusRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ConfigMapForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1EndpointsForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1EventForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1LimitRangeForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespaceRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedConfigMapRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedEndpointsRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedEventRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedLimitRangeRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedPersistentVolumeClaimRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedPodRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedPodTemplateRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedReplicationControllerRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedResourceQuotaRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedSecretRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedServiceRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NamespacedServiceAccountRequest {
    namespace: string;
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1NodeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PersistentVolumeRequest {
    pretty?: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PersistentVolumeClaimForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PodForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1PodTemplateForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ReplicationControllerForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ResourceQuotaForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1SecretForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ServiceAccountForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface ListCoreV1ServiceForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface PatchCoreV1NamespaceRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespaceStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NodeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1NodeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1PersistentVolumeRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface PatchCoreV1PersistentVolumeStatusRequest {
    name: string;
    body: object;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
    force?: boolean;
}

export interface ReadCoreV1ComponentStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1NamespaceRequest {
    name: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespaceStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedPodLogRequest {
    name: string;
    namespace: string;
    container?: string;
    follow?: boolean;
    limitBytes?: number;
    pretty?: string;
    previous?: boolean;
    sinceSeconds?: number;
    tailLines?: number;
    timestamps?: boolean;
}

export interface ReadCoreV1NamespacedPodStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    pretty?: string;
}

export interface ReadCoreV1NodeRequest {
    name: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1NodeStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReadCoreV1PersistentVolumeRequest {
    name: string;
    pretty?: string;
    exact?: boolean;
    _export?: boolean;
}

export interface ReadCoreV1PersistentVolumeStatusRequest {
    name: string;
    pretty?: string;
}

export interface ReplaceCoreV1NamespaceRequest {
    name: string;
    body: IoK8sApiCoreV1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespaceFinalizeRequest {
    name: string;
    body: IoK8sApiCoreV1Namespace;
    dryRun?: string;
    fieldManager?: string;
    pretty?: string;
}

export interface ReplaceCoreV1NamespaceStatusRequest {
    name: string;
    body: IoK8sApiCoreV1Namespace;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ConfigMap;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Endpoints;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Event;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1LimitRange;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1PersistentVolumeClaim;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedPodStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Pod;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1PodTemplate;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedReplicationControllerScaleRequest {
    name: string;
    namespace: string;
    body: IoK8sApiAutoscalingV1Scale;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedReplicationControllerStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ReplicationController;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedResourceQuotaStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ResourceQuota;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Secret;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1ServiceAccount;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NamespacedServiceStatusRequest {
    name: string;
    namespace: string;
    body: IoK8sApiCoreV1Service;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NodeRequest {
    name: string;
    body: IoK8sApiCoreV1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1NodeStatusRequest {
    name: string;
    body: IoK8sApiCoreV1Node;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1PersistentVolumeRequest {
    name: string;
    body: IoK8sApiCoreV1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface ReplaceCoreV1PersistentVolumeStatusRequest {
    name: string;
    body: IoK8sApiCoreV1PersistentVolume;
    pretty?: string;
    dryRun?: string;
    fieldManager?: string;
}

export interface WatchCoreV1ConfigMapListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1EndpointsListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1EventListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1LimitRangeListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespaceRequest {
    name: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespaceListRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedConfigMapRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedConfigMapListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEndpointsRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEndpointsListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEventRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedEventListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedLimitRangeRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedLimitRangeListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPersistentVolumeClaimRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPersistentVolumeClaimListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodTemplateRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedPodTemplateListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedReplicationControllerRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedReplicationControllerListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedResourceQuotaRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedResourceQuotaListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedSecretRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedSecretListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceAccountRequest {
    name: string;
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceAccountListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NamespacedServiceListRequest {
    namespace: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NodeRequest {
    name: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1NodeListRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PersistentVolumeRequest {
    name: string;
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PersistentVolumeListRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PodListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1PodTemplateListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ReplicationControllerListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ResourceQuotaListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1SecretListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ServiceAccountListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

export interface WatchCoreV1ServiceListForAllNamespacesRequest {
    allowWatchBookmarks?: boolean;
    _continue?: string;
    fieldSelector?: string;
    labelSelector?: string;
    limit?: number;
    pretty?: string;
    resourceVersion?: string;
    timeoutSeconds?: number;
    watch?: boolean;
}

/**
 * no description
 */
export class CoreV1Api extends runtime.BaseAPI {

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxyRaw(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxy(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1DeleteNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect DELETE requests to proxy of Pod
     */
    async connectCoreV1DeleteNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1DeleteNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxy(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1DeleteNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect DELETE requests to proxy of Service
     */
    async connectCoreV1DeleteNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1DeleteNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1DeleteNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxyRaw(requestParameters: ConnectCoreV1DeleteNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxy(requestParameters: ConnectCoreV1DeleteNodeProxyRequest): Promise<string> {
        const response = await this.connectCoreV1DeleteNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxyWithPathRaw(requestParameters: ConnectCoreV1DeleteNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1DeleteNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1DeleteNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect DELETE requests to proxy of Node
     */
    async connectCoreV1DeleteNodeProxyWithPath(requestParameters: ConnectCoreV1DeleteNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1DeleteNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectCoreV1GetNamespacedPodAttachRaw(requestParameters: ConnectCoreV1GetNamespacedPodAttachRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodAttach.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodAttach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to attach of Pod
     */
    async connectCoreV1GetNamespacedPodAttach(requestParameters: ConnectCoreV1GetNamespacedPodAttachRequest): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodAttachRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectCoreV1GetNamespacedPodExecRaw(requestParameters: ConnectCoreV1GetNamespacedPodExecRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodExec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodExec.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.command !== undefined) {
            queryParameters['command'] = requestParameters.command;
        }

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to exec of Pod
     */
    async connectCoreV1GetNamespacedPodExec(requestParameters: ConnectCoreV1GetNamespacedPodExecRequest): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodExecRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectCoreV1GetNamespacedPodPortforwardRaw(requestParameters: ConnectCoreV1GetNamespacedPodPortforwardRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodPortforward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodPortforward.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.ports !== undefined) {
            queryParameters['ports'] = requestParameters.ports;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to portforward of Pod
     */
    async connectCoreV1GetNamespacedPodPortforward(requestParameters: ConnectCoreV1GetNamespacedPodPortforwardRequest): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodPortforwardRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxyRaw(requestParameters: ConnectCoreV1GetNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxy(requestParameters: ConnectCoreV1GetNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1GetNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1GetNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to proxy of Pod
     */
    async connectCoreV1GetNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1GetNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1GetNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxy(requestParameters: ConnectCoreV1GetNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1GetNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1GetNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1GetNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to proxy of Service
     */
    async connectCoreV1GetNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1GetNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1GetNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxyRaw(requestParameters: ConnectCoreV1GetNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxy(requestParameters: ConnectCoreV1GetNodeProxyRequest): Promise<string> {
        const response = await this.connectCoreV1GetNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxyWithPathRaw(requestParameters: ConnectCoreV1GetNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1GetNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1GetNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect GET requests to proxy of Node
     */
    async connectCoreV1GetNodeProxyWithPath(requestParameters: ConnectCoreV1GetNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1GetNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxyRaw(requestParameters: ConnectCoreV1HeadNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxy(requestParameters: ConnectCoreV1HeadNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1HeadNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1HeadNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect HEAD requests to proxy of Pod
     */
    async connectCoreV1HeadNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1HeadNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxy(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1HeadNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1HeadNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect HEAD requests to proxy of Service
     */
    async connectCoreV1HeadNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1HeadNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1HeadNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxyRaw(requestParameters: ConnectCoreV1HeadNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxy(requestParameters: ConnectCoreV1HeadNodeProxyRequest): Promise<string> {
        const response = await this.connectCoreV1HeadNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxyWithPathRaw(requestParameters: ConnectCoreV1HeadNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1HeadNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1HeadNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'HEAD',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect HEAD requests to proxy of Node
     */
    async connectCoreV1HeadNodeProxyWithPath(requestParameters: ConnectCoreV1HeadNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1HeadNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxyRaw(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxy(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1OptionsNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect OPTIONS requests to proxy of Pod
     */
    async connectCoreV1OptionsNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1OptionsNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxy(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1OptionsNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect OPTIONS requests to proxy of Service
     */
    async connectCoreV1OptionsNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1OptionsNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1OptionsNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxyRaw(requestParameters: ConnectCoreV1OptionsNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxy(requestParameters: ConnectCoreV1OptionsNodeProxyRequest): Promise<string> {
        const response = await this.connectCoreV1OptionsNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxyWithPathRaw(requestParameters: ConnectCoreV1OptionsNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1OptionsNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1OptionsNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'OPTIONS',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect OPTIONS requests to proxy of Node
     */
    async connectCoreV1OptionsNodeProxyWithPath(requestParameters: ConnectCoreV1OptionsNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1OptionsNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxyRaw(requestParameters: ConnectCoreV1PatchNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxy(requestParameters: ConnectCoreV1PatchNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1PatchNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PatchNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PATCH requests to proxy of Pod
     */
    async connectCoreV1PatchNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1PatchNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxy(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PatchNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PatchNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PATCH requests to proxy of Service
     */
    async connectCoreV1PatchNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1PatchNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PatchNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxyRaw(requestParameters: ConnectCoreV1PatchNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxy(requestParameters: ConnectCoreV1PatchNodeProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PatchNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxyWithPathRaw(requestParameters: ConnectCoreV1PatchNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PatchNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PatchNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PATCH requests to proxy of Node
     */
    async connectCoreV1PatchNodeProxyWithPath(requestParameters: ConnectCoreV1PatchNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PatchNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectCoreV1PostNamespacedPodAttachRaw(requestParameters: ConnectCoreV1PostNamespacedPodAttachRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodAttach.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodAttach.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/attach`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to attach of Pod
     */
    async connectCoreV1PostNamespacedPodAttach(requestParameters: ConnectCoreV1PostNamespacedPodAttachRequest): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodAttachRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectCoreV1PostNamespacedPodExecRaw(requestParameters: ConnectCoreV1PostNamespacedPodExecRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodExec.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodExec.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.command !== undefined) {
            queryParameters['command'] = requestParameters.command;
        }

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.stderr !== undefined) {
            queryParameters['stderr'] = requestParameters.stderr;
        }

        if (requestParameters.stdin !== undefined) {
            queryParameters['stdin'] = requestParameters.stdin;
        }

        if (requestParameters.stdout !== undefined) {
            queryParameters['stdout'] = requestParameters.stdout;
        }

        if (requestParameters.tty !== undefined) {
            queryParameters['tty'] = requestParameters.tty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/exec`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to exec of Pod
     */
    async connectCoreV1PostNamespacedPodExec(requestParameters: ConnectCoreV1PostNamespacedPodExecRequest): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodExecRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectCoreV1PostNamespacedPodPortforwardRaw(requestParameters: ConnectCoreV1PostNamespacedPodPortforwardRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodPortforward.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodPortforward.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.ports !== undefined) {
            queryParameters['ports'] = requestParameters.ports;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/portforward`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to portforward of Pod
     */
    async connectCoreV1PostNamespacedPodPortforward(requestParameters: ConnectCoreV1PostNamespacedPodPortforwardRequest): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodPortforwardRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxyRaw(requestParameters: ConnectCoreV1PostNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxy(requestParameters: ConnectCoreV1PostNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1PostNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PostNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to proxy of Pod
     */
    async connectCoreV1PostNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1PostNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1PostNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxy(requestParameters: ConnectCoreV1PostNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1PostNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PostNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PostNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to proxy of Service
     */
    async connectCoreV1PostNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1PostNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PostNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxyRaw(requestParameters: ConnectCoreV1PostNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxy(requestParameters: ConnectCoreV1PostNodeProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PostNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxyWithPathRaw(requestParameters: ConnectCoreV1PostNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PostNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PostNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect POST requests to proxy of Node
     */
    async connectCoreV1PostNodeProxyWithPath(requestParameters: ConnectCoreV1PostNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PostNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxyRaw(requestParameters: ConnectCoreV1PutNamespacedPodProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedPodProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedPodProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxy(requestParameters: ConnectCoreV1PutNamespacedPodProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedPodProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxyWithPathRaw(requestParameters: ConnectCoreV1PutNamespacedPodProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedPodProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedPodProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PutNamespacedPodProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PUT requests to proxy of Pod
     */
    async connectCoreV1PutNamespacedPodProxyWithPath(requestParameters: ConnectCoreV1PutNamespacedPodProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedPodProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxyRaw(requestParameters: ConnectCoreV1PutNamespacedServiceProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedServiceProxy.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedServiceProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxy(requestParameters: ConnectCoreV1PutNamespacedServiceProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedServiceProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxyWithPathRaw(requestParameters: ConnectCoreV1PutNamespacedServiceProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling connectCoreV1PutNamespacedServiceProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PutNamespacedServiceProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PUT requests to proxy of Service
     */
    async connectCoreV1PutNamespacedServiceProxyWithPath(requestParameters: ConnectCoreV1PutNamespacedServiceProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PutNamespacedServiceProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxyRaw(requestParameters: ConnectCoreV1PutNodeProxyRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNodeProxy.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path !== undefined) {
            queryParameters['path'] = requestParameters.path;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxy(requestParameters: ConnectCoreV1PutNodeProxyRequest): Promise<string> {
        const response = await this.connectCoreV1PutNodeProxyRaw(requestParameters);
        return await response.value();
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxyWithPathRaw(requestParameters: ConnectCoreV1PutNodeProxyWithPathRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling connectCoreV1PutNodeProxyWithPath.');
        }

        if (requestParameters.path === null || requestParameters.path === undefined) {
            throw new runtime.RequiredError('path','Required parameter requestParameters.path was null or undefined when calling connectCoreV1PutNodeProxyWithPath.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.path2 !== undefined) {
            queryParameters['path'] = requestParameters.path2;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/proxy/{path}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"path"}}`, encodeURIComponent(String(requestParameters.path))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * connect PUT requests to proxy of Node
     */
    async connectCoreV1PutNodeProxyWithPath(requestParameters: ConnectCoreV1PutNodeProxyWithPathRequest): Promise<string> {
        const response = await this.connectCoreV1PutNodeProxyWithPathRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Namespace
     */
    async createCoreV1NamespaceRaw(requestParameters: CreateCoreV1NamespaceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1Namespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * create a Namespace
     */
    async createCoreV1Namespace(requestParameters: CreateCoreV1NamespaceRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.createCoreV1NamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Binding
     */
    async createCoreV1NamespacedBindingRaw(requestParameters: CreateCoreV1NamespacedBindingRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Binding>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedBinding.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedBinding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/bindings`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1BindingToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1BindingFromJSON(jsonValue));
    }

    /**
     * create a Binding
     */
    async createCoreV1NamespacedBinding(requestParameters: CreateCoreV1NamespacedBindingRequest): Promise<IoK8sApiCoreV1Binding> {
        const response = await this.createCoreV1NamespacedBindingRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ConfigMap
     */
    async createCoreV1NamespacedConfigMapRaw(requestParameters: CreateCoreV1NamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ConfigMapToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * create a ConfigMap
     */
    async createCoreV1NamespacedConfigMap(requestParameters: CreateCoreV1NamespacedConfigMapRequest): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.createCoreV1NamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * create Endpoints
     */
    async createCoreV1NamespacedEndpointsRaw(requestParameters: CreateCoreV1NamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EndpointsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * create Endpoints
     */
    async createCoreV1NamespacedEndpoints(requestParameters: CreateCoreV1NamespacedEndpointsRequest): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.createCoreV1NamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * create an Event
     */
    async createCoreV1NamespacedEventRaw(requestParameters: CreateCoreV1NamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EventToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * create an Event
     */
    async createCoreV1NamespacedEvent(requestParameters: CreateCoreV1NamespacedEventRequest): Promise<IoK8sApiCoreV1Event> {
        const response = await this.createCoreV1NamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a LimitRange
     */
    async createCoreV1NamespacedLimitRangeRaw(requestParameters: CreateCoreV1NamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1LimitRangeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * create a LimitRange
     */
    async createCoreV1NamespacedLimitRange(requestParameters: CreateCoreV1NamespacedLimitRangeRequest): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.createCoreV1NamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: CreateCoreV1NamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeClaimToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolumeClaim
     */
    async createCoreV1NamespacedPersistentVolumeClaim(requestParameters: CreateCoreV1NamespacedPersistentVolumeClaimRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.createCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Pod
     */
    async createCoreV1NamespacedPodRaw(requestParameters: CreateCoreV1NamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * create a Pod
     */
    async createCoreV1NamespacedPod(requestParameters: CreateCoreV1NamespacedPodRequest): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.createCoreV1NamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * create binding of a Pod
     */
    async createCoreV1NamespacedPodBindingRaw(requestParameters: CreateCoreV1NamespacedPodBindingRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Binding>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createCoreV1NamespacedPodBinding.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPodBinding.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPodBinding.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/binding`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1BindingToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1BindingFromJSON(jsonValue));
    }

    /**
     * create binding of a Pod
     */
    async createCoreV1NamespacedPodBinding(requestParameters: CreateCoreV1NamespacedPodBindingRequest): Promise<IoK8sApiCoreV1Binding> {
        const response = await this.createCoreV1NamespacedPodBindingRaw(requestParameters);
        return await response.value();
    }

    /**
     * create eviction of a Pod
     */
    async createCoreV1NamespacedPodEvictionRaw(requestParameters: CreateCoreV1NamespacedPodEvictionRequest): Promise<runtime.ApiResponse<IoK8sApiPolicyV1beta1Eviction>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling createCoreV1NamespacedPodEviction.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPodEviction.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPodEviction.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/eviction`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiPolicyV1beta1EvictionToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiPolicyV1beta1EvictionFromJSON(jsonValue));
    }

    /**
     * create eviction of a Pod
     */
    async createCoreV1NamespacedPodEviction(requestParameters: CreateCoreV1NamespacedPodEvictionRequest): Promise<IoK8sApiPolicyV1beta1Eviction> {
        const response = await this.createCoreV1NamespacedPodEvictionRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a PodTemplate
     */
    async createCoreV1NamespacedPodTemplateRaw(requestParameters: CreateCoreV1NamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodTemplateToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * create a PodTemplate
     */
    async createCoreV1NamespacedPodTemplate(requestParameters: CreateCoreV1NamespacedPodTemplateRequest): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.createCoreV1NamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ReplicationController
     */
    async createCoreV1NamespacedReplicationControllerRaw(requestParameters: CreateCoreV1NamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ReplicationControllerToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * create a ReplicationController
     */
    async createCoreV1NamespacedReplicationController(requestParameters: CreateCoreV1NamespacedReplicationControllerRequest): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.createCoreV1NamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ResourceQuota
     */
    async createCoreV1NamespacedResourceQuotaRaw(requestParameters: CreateCoreV1NamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ResourceQuotaToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * create a ResourceQuota
     */
    async createCoreV1NamespacedResourceQuota(requestParameters: CreateCoreV1NamespacedResourceQuotaRequest): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.createCoreV1NamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Secret
     */
    async createCoreV1NamespacedSecretRaw(requestParameters: CreateCoreV1NamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1SecretToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * create a Secret
     */
    async createCoreV1NamespacedSecret(requestParameters: CreateCoreV1NamespacedSecretRequest): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.createCoreV1NamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Service
     */
    async createCoreV1NamespacedServiceRaw(requestParameters: CreateCoreV1NamespacedServiceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * create a Service
     */
    async createCoreV1NamespacedService(requestParameters: CreateCoreV1NamespacedServiceRequest): Promise<IoK8sApiCoreV1Service> {
        const response = await this.createCoreV1NamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a ServiceAccount
     */
    async createCoreV1NamespacedServiceAccountRaw(requestParameters: CreateCoreV1NamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling createCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceAccountToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * create a ServiceAccount
     */
    async createCoreV1NamespacedServiceAccount(requestParameters: CreateCoreV1NamespacedServiceAccountRequest): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.createCoreV1NamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a Node
     */
    async createCoreV1NodeRaw(requestParameters: CreateCoreV1NodeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1Node.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NodeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * create a Node
     */
    async createCoreV1Node(requestParameters: CreateCoreV1NodeRequest): Promise<IoK8sApiCoreV1Node> {
        const response = await this.createCoreV1NodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * create a PersistentVolume
     */
    async createCoreV1PersistentVolumeRaw(requestParameters: CreateCoreV1PersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling createCoreV1PersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * create a PersistentVolume
     */
    async createCoreV1PersistentVolume(requestParameters: CreateCoreV1PersistentVolumeRequest): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.createCoreV1PersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCoreV1CollectionNamespacedConfigMapRaw(requestParameters: DeleteCoreV1CollectionNamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ConfigMap
     */
    async deleteCoreV1CollectionNamespacedConfigMap(requestParameters: DeleteCoreV1CollectionNamespacedConfigMapRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCoreV1CollectionNamespacedEndpointsRaw(requestParameters: DeleteCoreV1CollectionNamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Endpoints
     */
    async deleteCoreV1CollectionNamespacedEndpoints(requestParameters: DeleteCoreV1CollectionNamespacedEndpointsRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Event
     */
    async deleteCoreV1CollectionNamespacedEventRaw(requestParameters: DeleteCoreV1CollectionNamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Event
     */
    async deleteCoreV1CollectionNamespacedEvent(requestParameters: DeleteCoreV1CollectionNamespacedEventRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCoreV1CollectionNamespacedLimitRangeRaw(requestParameters: DeleteCoreV1CollectionNamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of LimitRange
     */
    async deleteCoreV1CollectionNamespacedLimitRange(requestParameters: DeleteCoreV1CollectionNamespacedLimitRangeRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCoreV1CollectionNamespacedPersistentVolumeClaimRaw(requestParameters: DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolumeClaim
     */
    async deleteCoreV1CollectionNamespacedPersistentVolumeClaim(requestParameters: DeleteCoreV1CollectionNamespacedPersistentVolumeClaimRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Pod
     */
    async deleteCoreV1CollectionNamespacedPodRaw(requestParameters: DeleteCoreV1CollectionNamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Pod
     */
    async deleteCoreV1CollectionNamespacedPod(requestParameters: DeleteCoreV1CollectionNamespacedPodRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCoreV1CollectionNamespacedPodTemplateRaw(requestParameters: DeleteCoreV1CollectionNamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PodTemplate
     */
    async deleteCoreV1CollectionNamespacedPodTemplate(requestParameters: DeleteCoreV1CollectionNamespacedPodTemplateRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCoreV1CollectionNamespacedReplicationControllerRaw(requestParameters: DeleteCoreV1CollectionNamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ReplicationController
     */
    async deleteCoreV1CollectionNamespacedReplicationController(requestParameters: DeleteCoreV1CollectionNamespacedReplicationControllerRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCoreV1CollectionNamespacedResourceQuotaRaw(requestParameters: DeleteCoreV1CollectionNamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ResourceQuota
     */
    async deleteCoreV1CollectionNamespacedResourceQuota(requestParameters: DeleteCoreV1CollectionNamespacedResourceQuotaRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Secret
     */
    async deleteCoreV1CollectionNamespacedSecretRaw(requestParameters: DeleteCoreV1CollectionNamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Secret
     */
    async deleteCoreV1CollectionNamespacedSecret(requestParameters: DeleteCoreV1CollectionNamespacedSecretRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCoreV1CollectionNamespacedServiceAccountRaw(requestParameters: DeleteCoreV1CollectionNamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1CollectionNamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of ServiceAccount
     */
    async deleteCoreV1CollectionNamespacedServiceAccount(requestParameters: DeleteCoreV1CollectionNamespacedServiceAccountRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of Node
     */
    async deleteCoreV1CollectionNodeRaw(requestParameters: DeleteCoreV1CollectionNodeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of Node
     */
    async deleteCoreV1CollectionNode(requestParameters: DeleteCoreV1CollectionNodeRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionNodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCoreV1CollectionPersistentVolumeRaw(requestParameters: DeleteCoreV1CollectionPersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete collection of PersistentVolume
     */
    async deleteCoreV1CollectionPersistentVolume(requestParameters: DeleteCoreV1CollectionPersistentVolumeRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1CollectionPersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Namespace
     */
    async deleteCoreV1NamespaceRaw(requestParameters: DeleteCoreV1NamespaceRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1Namespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Namespace
     */
    async deleteCoreV1Namespace(requestParameters: DeleteCoreV1NamespaceRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ConfigMap
     */
    async deleteCoreV1NamespacedConfigMapRaw(requestParameters: DeleteCoreV1NamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ConfigMap
     */
    async deleteCoreV1NamespacedConfigMap(requestParameters: DeleteCoreV1NamespacedConfigMapRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete Endpoints
     */
    async deleteCoreV1NamespacedEndpointsRaw(requestParameters: DeleteCoreV1NamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete Endpoints
     */
    async deleteCoreV1NamespacedEndpoints(requestParameters: DeleteCoreV1NamespacedEndpointsRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete an Event
     */
    async deleteCoreV1NamespacedEventRaw(requestParameters: DeleteCoreV1NamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete an Event
     */
    async deleteCoreV1NamespacedEvent(requestParameters: DeleteCoreV1NamespacedEventRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a LimitRange
     */
    async deleteCoreV1NamespacedLimitRangeRaw(requestParameters: DeleteCoreV1NamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a LimitRange
     */
    async deleteCoreV1NamespacedLimitRange(requestParameters: DeleteCoreV1NamespacedLimitRangeRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: DeleteCoreV1NamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolumeClaim
     */
    async deleteCoreV1NamespacedPersistentVolumeClaim(requestParameters: DeleteCoreV1NamespacedPersistentVolumeClaimRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Pod
     */
    async deleteCoreV1NamespacedPodRaw(requestParameters: DeleteCoreV1NamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Pod
     */
    async deleteCoreV1NamespacedPod(requestParameters: DeleteCoreV1NamespacedPodRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a PodTemplate
     */
    async deleteCoreV1NamespacedPodTemplateRaw(requestParameters: DeleteCoreV1NamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a PodTemplate
     */
    async deleteCoreV1NamespacedPodTemplate(requestParameters: DeleteCoreV1NamespacedPodTemplateRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ReplicationController
     */
    async deleteCoreV1NamespacedReplicationControllerRaw(requestParameters: DeleteCoreV1NamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ReplicationController
     */
    async deleteCoreV1NamespacedReplicationController(requestParameters: DeleteCoreV1NamespacedReplicationControllerRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ResourceQuota
     */
    async deleteCoreV1NamespacedResourceQuotaRaw(requestParameters: DeleteCoreV1NamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ResourceQuota
     */
    async deleteCoreV1NamespacedResourceQuota(requestParameters: DeleteCoreV1NamespacedResourceQuotaRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Secret
     */
    async deleteCoreV1NamespacedSecretRaw(requestParameters: DeleteCoreV1NamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Secret
     */
    async deleteCoreV1NamespacedSecret(requestParameters: DeleteCoreV1NamespacedSecretRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Service
     */
    async deleteCoreV1NamespacedServiceRaw(requestParameters: DeleteCoreV1NamespacedServiceRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Service
     */
    async deleteCoreV1NamespacedService(requestParameters: DeleteCoreV1NamespacedServiceRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a ServiceAccount
     */
    async deleteCoreV1NamespacedServiceAccountRaw(requestParameters: DeleteCoreV1NamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling deleteCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a ServiceAccount
     */
    async deleteCoreV1NamespacedServiceAccount(requestParameters: DeleteCoreV1NamespacedServiceAccountRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a Node
     */
    async deleteCoreV1NodeRaw(requestParameters: DeleteCoreV1NodeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1Node.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a Node
     */
    async deleteCoreV1Node(requestParameters: DeleteCoreV1NodeRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1NodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * delete a PersistentVolume
     */
    async deleteCoreV1PersistentVolumeRaw(requestParameters: DeleteCoreV1PersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1Status>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling deleteCoreV1PersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.gracePeriodSeconds !== undefined) {
            queryParameters['gracePeriodSeconds'] = requestParameters.gracePeriodSeconds;
        }

        if (requestParameters.orphanDependents !== undefined) {
            queryParameters['orphanDependents'] = requestParameters.orphanDependents;
        }

        if (requestParameters.propagationPolicy !== undefined) {
            queryParameters['propagationPolicy'] = requestParameters.propagationPolicy;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApimachineryPkgApisMetaV1DeleteOptionsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1StatusFromJSON(jsonValue));
    }

    /**
     * delete a PersistentVolume
     */
    async deleteCoreV1PersistentVolume(requestParameters: DeleteCoreV1PersistentVolumeRequest): Promise<IoK8sApimachineryPkgApisMetaV1Status> {
        const response = await this.deleteCoreV1PersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * get available resources
     */
    async getCoreV1APIResourcesRaw(): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1APIResourceList>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1APIResourceListFromJSON(jsonValue));
    }

    /**
     * get available resources
     */
    async getCoreV1APIResources(): Promise<IoK8sApimachineryPkgApisMetaV1APIResourceList> {
        const response = await this.getCoreV1APIResourcesRaw();
        return await response.value();
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listCoreV1ComponentStatusRaw(requestParameters: ListCoreV1ComponentStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ComponentStatusList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ComponentStatusListFromJSON(jsonValue));
    }

    /**
     * list objects of kind ComponentStatus
     */
    async listCoreV1ComponentStatus(requestParameters: ListCoreV1ComponentStatusRequest): Promise<IoK8sApiCoreV1ComponentStatusList> {
        const response = await this.listCoreV1ComponentStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1ConfigMapForAllNamespacesRaw(requestParameters: ListCoreV1ConfigMapForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMapList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/configmaps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1ConfigMapForAllNamespaces(requestParameters: ListCoreV1ConfigMapForAllNamespacesRequest): Promise<IoK8sApiCoreV1ConfigMapList> {
        const response = await this.listCoreV1ConfigMapForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1EndpointsForAllNamespacesRaw(requestParameters: ListCoreV1EndpointsForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1EndpointsList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/endpoints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1EndpointsForAllNamespaces(requestParameters: ListCoreV1EndpointsForAllNamespacesRequest): Promise<IoK8sApiCoreV1EndpointsList> {
        const response = await this.listCoreV1EndpointsForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1EventForAllNamespacesRaw(requestParameters: ListCoreV1EventForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1EventList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1EventForAllNamespaces(requestParameters: ListCoreV1EventForAllNamespacesRequest): Promise<IoK8sApiCoreV1EventList> {
        const response = await this.listCoreV1EventForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1LimitRangeForAllNamespacesRaw(requestParameters: ListCoreV1LimitRangeForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRangeList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/limitranges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1LimitRangeForAllNamespaces(requestParameters: ListCoreV1LimitRangeForAllNamespacesRequest): Promise<IoK8sApiCoreV1LimitRangeList> {
        const response = await this.listCoreV1LimitRangeForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listCoreV1NamespaceRaw(requestParameters: ListCoreV1NamespaceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1NamespaceList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Namespace
     */
    async listCoreV1Namespace(requestParameters: ListCoreV1NamespaceRequest): Promise<IoK8sApiCoreV1NamespaceList> {
        const response = await this.listCoreV1NamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1NamespacedConfigMapRaw(requestParameters: ListCoreV1NamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMapList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ConfigMap
     */
    async listCoreV1NamespacedConfigMap(requestParameters: ListCoreV1NamespacedConfigMapRequest): Promise<IoK8sApiCoreV1ConfigMapList> {
        const response = await this.listCoreV1NamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1NamespacedEndpointsRaw(requestParameters: ListCoreV1NamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1EndpointsList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Endpoints
     */
    async listCoreV1NamespacedEndpoints(requestParameters: ListCoreV1NamespacedEndpointsRequest): Promise<IoK8sApiCoreV1EndpointsList> {
        const response = await this.listCoreV1NamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1NamespacedEventRaw(requestParameters: ListCoreV1NamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1EventList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Event
     */
    async listCoreV1NamespacedEvent(requestParameters: ListCoreV1NamespacedEventRequest): Promise<IoK8sApiCoreV1EventList> {
        const response = await this.listCoreV1NamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1NamespacedLimitRangeRaw(requestParameters: ListCoreV1NamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRangeList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind LimitRange
     */
    async listCoreV1NamespacedLimitRange(requestParameters: ListCoreV1NamespacedLimitRangeRequest): Promise<IoK8sApiCoreV1LimitRangeList> {
        const response = await this.listCoreV1NamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: ListCoreV1NamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaimList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1NamespacedPersistentVolumeClaim(requestParameters: ListCoreV1NamespacedPersistentVolumeClaimRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaimList> {
        const response = await this.listCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1NamespacedPodRaw(requestParameters: ListCoreV1NamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1NamespacedPod(requestParameters: ListCoreV1NamespacedPodRequest): Promise<IoK8sApiCoreV1PodList> {
        const response = await this.listCoreV1NamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1NamespacedPodTemplateRaw(requestParameters: ListCoreV1NamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplateList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1NamespacedPodTemplate(requestParameters: ListCoreV1NamespacedPodTemplateRequest): Promise<IoK8sApiCoreV1PodTemplateList> {
        const response = await this.listCoreV1NamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1NamespacedReplicationControllerRaw(requestParameters: ListCoreV1NamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationControllerList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1NamespacedReplicationController(requestParameters: ListCoreV1NamespacedReplicationControllerRequest): Promise<IoK8sApiCoreV1ReplicationControllerList> {
        const response = await this.listCoreV1NamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1NamespacedResourceQuotaRaw(requestParameters: ListCoreV1NamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuotaList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1NamespacedResourceQuota(requestParameters: ListCoreV1NamespacedResourceQuotaRequest): Promise<IoK8sApiCoreV1ResourceQuotaList> {
        const response = await this.listCoreV1NamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1NamespacedSecretRaw(requestParameters: ListCoreV1NamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1SecretList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1NamespacedSecret(requestParameters: ListCoreV1NamespacedSecretRequest): Promise<IoK8sApiCoreV1SecretList> {
        const response = await this.listCoreV1NamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1NamespacedServiceRaw(requestParameters: ListCoreV1NamespacedServiceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1NamespacedService(requestParameters: ListCoreV1NamespacedServiceRequest): Promise<IoK8sApiCoreV1ServiceList> {
        const response = await this.listCoreV1NamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1NamespacedServiceAccountRaw(requestParameters: ListCoreV1NamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccountList>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling listCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1NamespacedServiceAccount(requestParameters: ListCoreV1NamespacedServiceAccountRequest): Promise<IoK8sApiCoreV1ServiceAccountList> {
        const response = await this.listCoreV1NamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Node
     */
    async listCoreV1NodeRaw(requestParameters: ListCoreV1NodeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1NodeList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Node
     */
    async listCoreV1Node(requestParameters: ListCoreV1NodeRequest): Promise<IoK8sApiCoreV1NodeList> {
        const response = await this.listCoreV1NodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listCoreV1PersistentVolumeRaw(requestParameters: ListCoreV1PersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolume
     */
    async listCoreV1PersistentVolume(requestParameters: ListCoreV1PersistentVolumeRequest): Promise<IoK8sApiCoreV1PersistentVolumeList> {
        const response = await this.listCoreV1PersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1PersistentVolumeClaimForAllNamespacesRaw(requestParameters: ListCoreV1PersistentVolumeClaimForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaimList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumeclaims`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PersistentVolumeClaim
     */
    async listCoreV1PersistentVolumeClaimForAllNamespaces(requestParameters: ListCoreV1PersistentVolumeClaimForAllNamespacesRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaimList> {
        const response = await this.listCoreV1PersistentVolumeClaimForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1PodForAllNamespacesRaw(requestParameters: ListCoreV1PodForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/pods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Pod
     */
    async listCoreV1PodForAllNamespaces(requestParameters: ListCoreV1PodForAllNamespacesRequest): Promise<IoK8sApiCoreV1PodList> {
        const response = await this.listCoreV1PodForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1PodTemplateForAllNamespacesRaw(requestParameters: ListCoreV1PodTemplateForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplateList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/podtemplates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind PodTemplate
     */
    async listCoreV1PodTemplateForAllNamespaces(requestParameters: ListCoreV1PodTemplateForAllNamespacesRequest): Promise<IoK8sApiCoreV1PodTemplateList> {
        const response = await this.listCoreV1PodTemplateForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1ReplicationControllerForAllNamespacesRaw(requestParameters: ListCoreV1ReplicationControllerForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationControllerList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/replicationcontrollers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ReplicationController
     */
    async listCoreV1ReplicationControllerForAllNamespaces(requestParameters: ListCoreV1ReplicationControllerForAllNamespacesRequest): Promise<IoK8sApiCoreV1ReplicationControllerList> {
        const response = await this.listCoreV1ReplicationControllerForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1ResourceQuotaForAllNamespacesRaw(requestParameters: ListCoreV1ResourceQuotaForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuotaList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/resourcequotas`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ResourceQuota
     */
    async listCoreV1ResourceQuotaForAllNamespaces(requestParameters: ListCoreV1ResourceQuotaForAllNamespacesRequest): Promise<IoK8sApiCoreV1ResourceQuotaList> {
        const response = await this.listCoreV1ResourceQuotaForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1SecretForAllNamespacesRaw(requestParameters: ListCoreV1SecretForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1SecretList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/secrets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Secret
     */
    async listCoreV1SecretForAllNamespaces(requestParameters: ListCoreV1SecretForAllNamespacesRequest): Promise<IoK8sApiCoreV1SecretList> {
        const response = await this.listCoreV1SecretForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1ServiceAccountForAllNamespacesRaw(requestParameters: ListCoreV1ServiceAccountForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccountList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/serviceaccounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind ServiceAccount
     */
    async listCoreV1ServiceAccountForAllNamespaces(requestParameters: ListCoreV1ServiceAccountForAllNamespacesRequest): Promise<IoK8sApiCoreV1ServiceAccountList> {
        const response = await this.listCoreV1ServiceAccountForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1ServiceForAllNamespacesRaw(requestParameters: ListCoreV1ServiceForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceList>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/services`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceListFromJSON(jsonValue));
    }

    /**
     * list or watch objects of kind Service
     */
    async listCoreV1ServiceForAllNamespaces(requestParameters: ListCoreV1ServiceForAllNamespacesRequest): Promise<IoK8sApiCoreV1ServiceList> {
        const response = await this.listCoreV1ServiceForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Namespace
     */
    async patchCoreV1NamespaceRaw(requestParameters: PatchCoreV1NamespaceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1Namespace.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1Namespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Namespace
     */
    async patchCoreV1Namespace(requestParameters: PatchCoreV1NamespaceRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.patchCoreV1NamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchCoreV1NamespaceStatusRaw(requestParameters: PatchCoreV1NamespaceStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespaceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespaceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Namespace
     */
    async patchCoreV1NamespaceStatus(requestParameters: PatchCoreV1NamespaceStatusRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.patchCoreV1NamespaceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchCoreV1NamespacedConfigMapRaw(requestParameters: PatchCoreV1NamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * partially update the specified ConfigMap
     */
    async patchCoreV1NamespacedConfigMap(requestParameters: PatchCoreV1NamespacedConfigMapRequest): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.patchCoreV1NamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Endpoints
     */
    async patchCoreV1NamespacedEndpointsRaw(requestParameters: PatchCoreV1NamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * partially update the specified Endpoints
     */
    async patchCoreV1NamespacedEndpoints(requestParameters: PatchCoreV1NamespacedEndpointsRequest): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.patchCoreV1NamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Event
     */
    async patchCoreV1NamespacedEventRaw(requestParameters: PatchCoreV1NamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * partially update the specified Event
     */
    async patchCoreV1NamespacedEvent(requestParameters: PatchCoreV1NamespacedEventRequest): Promise<IoK8sApiCoreV1Event> {
        const response = await this.patchCoreV1NamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified LimitRange
     */
    async patchCoreV1NamespacedLimitRangeRaw(requestParameters: PatchCoreV1NamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * partially update the specified LimitRange
     */
    async patchCoreV1NamespacedLimitRange(requestParameters: PatchCoreV1NamespacedLimitRangeRequest): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.patchCoreV1NamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaim(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.patchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolumeClaim
     */
    async patchCoreV1NamespacedPersistentVolumeClaimStatus(requestParameters: PatchCoreV1NamespacedPersistentVolumeClaimStatusRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.patchCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Pod
     */
    async patchCoreV1NamespacedPodRaw(requestParameters: PatchCoreV1NamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * partially update the specified Pod
     */
    async patchCoreV1NamespacedPod(requestParameters: PatchCoreV1NamespacedPodRequest): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.patchCoreV1NamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Pod
     */
    async patchCoreV1NamespacedPodStatusRaw(requestParameters: PatchCoreV1NamespacedPodStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPodStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Pod
     */
    async patchCoreV1NamespacedPodStatus(requestParameters: PatchCoreV1NamespacedPodStatusRequest): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.patchCoreV1NamespacedPodStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchCoreV1NamespacedPodTemplateRaw(requestParameters: PatchCoreV1NamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * partially update the specified PodTemplate
     */
    async patchCoreV1NamespacedPodTemplate(requestParameters: PatchCoreV1NamespacedPodTemplateRequest): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.patchCoreV1NamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerRaw(requestParameters: PatchCoreV1NamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationController(requestParameters: PatchCoreV1NamespacedReplicationControllerRequest): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.patchCoreV1NamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerScaleRaw(requestParameters: PatchCoreV1NamespacedReplicationControllerScaleRequest): Promise<runtime.ApiResponse<IoK8sApiAutoscalingV1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedReplicationControllerScale.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiAutoscalingV1ScaleFromJSON(jsonValue));
    }

    /**
     * partially update scale of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerScale(requestParameters: PatchCoreV1NamespacedReplicationControllerScaleRequest): Promise<IoK8sApiAutoscalingV1Scale> {
        const response = await this.patchCoreV1NamespacedReplicationControllerScaleRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerStatusRaw(requestParameters: PatchCoreV1NamespacedReplicationControllerStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedReplicationControllerStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ReplicationController
     */
    async patchCoreV1NamespacedReplicationControllerStatus(requestParameters: PatchCoreV1NamespacedReplicationControllerStatusRequest): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.patchCoreV1NamespacedReplicationControllerStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuotaRaw(requestParameters: PatchCoreV1NamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuota(requestParameters: PatchCoreV1NamespacedResourceQuotaRequest): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.patchCoreV1NamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuotaStatusRaw(requestParameters: PatchCoreV1NamespacedResourceQuotaStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedResourceQuotaStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified ResourceQuota
     */
    async patchCoreV1NamespacedResourceQuotaStatus(requestParameters: PatchCoreV1NamespacedResourceQuotaStatusRequest): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.patchCoreV1NamespacedResourceQuotaStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Secret
     */
    async patchCoreV1NamespacedSecretRaw(requestParameters: PatchCoreV1NamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * partially update the specified Secret
     */
    async patchCoreV1NamespacedSecret(requestParameters: PatchCoreV1NamespacedSecretRequest): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.patchCoreV1NamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Service
     */
    async patchCoreV1NamespacedServiceRaw(requestParameters: PatchCoreV1NamespacedServiceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update the specified Service
     */
    async patchCoreV1NamespacedService(requestParameters: PatchCoreV1NamespacedServiceRequest): Promise<IoK8sApiCoreV1Service> {
        const response = await this.patchCoreV1NamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchCoreV1NamespacedServiceAccountRaw(requestParameters: PatchCoreV1NamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * partially update the specified ServiceAccount
     */
    async patchCoreV1NamespacedServiceAccount(requestParameters: PatchCoreV1NamespacedServiceAccountRequest): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.patchCoreV1NamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Service
     */
    async patchCoreV1NamespacedServiceStatusRaw(requestParameters: PatchCoreV1NamespacedServiceStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling patchCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NamespacedServiceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Service
     */
    async patchCoreV1NamespacedServiceStatus(requestParameters: PatchCoreV1NamespacedServiceStatusRequest): Promise<IoK8sApiCoreV1Service> {
        const response = await this.patchCoreV1NamespacedServiceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified Node
     */
    async patchCoreV1NodeRaw(requestParameters: PatchCoreV1NodeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1Node.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1Node.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * partially update the specified Node
     */
    async patchCoreV1Node(requestParameters: PatchCoreV1NodeRequest): Promise<IoK8sApiCoreV1Node> {
        const response = await this.patchCoreV1NodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified Node
     */
    async patchCoreV1NodeStatusRaw(requestParameters: PatchCoreV1NodeStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1NodeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1NodeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified Node
     */
    async patchCoreV1NodeStatus(requestParameters: PatchCoreV1NodeStatusRequest): Promise<IoK8sApiCoreV1Node> {
        const response = await this.patchCoreV1NodeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchCoreV1PersistentVolumeRaw(requestParameters: PatchCoreV1PersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1PersistentVolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1PersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update the specified PersistentVolume
     */
    async patchCoreV1PersistentVolume(requestParameters: PatchCoreV1PersistentVolumeRequest): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.patchCoreV1PersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchCoreV1PersistentVolumeStatusRaw(requestParameters: PatchCoreV1PersistentVolumeStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling patchCoreV1PersistentVolumeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling patchCoreV1PersistentVolumeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json-patch+json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters.body as any,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * partially update status of the specified PersistentVolume
     */
    async patchCoreV1PersistentVolumeStatus(requestParameters: PatchCoreV1PersistentVolumeStatusRequest): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.patchCoreV1PersistentVolumeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ComponentStatus
     */
    async readCoreV1ComponentStatusRaw(requestParameters: ReadCoreV1ComponentStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ComponentStatus>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1ComponentStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/componentstatuses/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ComponentStatusFromJSON(jsonValue));
    }

    /**
     * read the specified ComponentStatus
     */
    async readCoreV1ComponentStatus(requestParameters: ReadCoreV1ComponentStatusRequest): Promise<IoK8sApiCoreV1ComponentStatus> {
        const response = await this.readCoreV1ComponentStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Namespace
     */
    async readCoreV1NamespaceRaw(requestParameters: ReadCoreV1NamespaceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1Namespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * read the specified Namespace
     */
    async readCoreV1Namespace(requestParameters: ReadCoreV1NamespaceRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.readCoreV1NamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Namespace
     */
    async readCoreV1NamespaceStatusRaw(requestParameters: ReadCoreV1NamespaceStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespaceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Namespace
     */
    async readCoreV1NamespaceStatus(requestParameters: ReadCoreV1NamespaceStatusRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.readCoreV1NamespaceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ConfigMap
     */
    async readCoreV1NamespacedConfigMapRaw(requestParameters: ReadCoreV1NamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * read the specified ConfigMap
     */
    async readCoreV1NamespacedConfigMap(requestParameters: ReadCoreV1NamespacedConfigMapRequest): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.readCoreV1NamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Endpoints
     */
    async readCoreV1NamespacedEndpointsRaw(requestParameters: ReadCoreV1NamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * read the specified Endpoints
     */
    async readCoreV1NamespacedEndpoints(requestParameters: ReadCoreV1NamespacedEndpointsRequest): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.readCoreV1NamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Event
     */
    async readCoreV1NamespacedEventRaw(requestParameters: ReadCoreV1NamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * read the specified Event
     */
    async readCoreV1NamespacedEvent(requestParameters: ReadCoreV1NamespacedEventRequest): Promise<IoK8sApiCoreV1Event> {
        const response = await this.readCoreV1NamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified LimitRange
     */
    async readCoreV1NamespacedLimitRangeRaw(requestParameters: ReadCoreV1NamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * read the specified LimitRange
     */
    async readCoreV1NamespacedLimitRange(requestParameters: ReadCoreV1NamespacedLimitRangeRequest): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.readCoreV1NamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaim(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.readCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolumeClaim
     */
    async readCoreV1NamespacedPersistentVolumeClaimStatus(requestParameters: ReadCoreV1NamespacedPersistentVolumeClaimStatusRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.readCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Pod
     */
    async readCoreV1NamespacedPodRaw(requestParameters: ReadCoreV1NamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * read the specified Pod
     */
    async readCoreV1NamespacedPod(requestParameters: ReadCoreV1NamespacedPodRequest): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.readCoreV1NamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * read log of the specified Pod
     */
    async readCoreV1NamespacedPodLogRaw(requestParameters: ReadCoreV1NamespacedPodLogRequest): Promise<runtime.ApiResponse<string>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPodLog.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPodLog.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.container !== undefined) {
            queryParameters['container'] = requestParameters.container;
        }

        if (requestParameters.follow !== undefined) {
            queryParameters['follow'] = requestParameters.follow;
        }

        if (requestParameters.limitBytes !== undefined) {
            queryParameters['limitBytes'] = requestParameters.limitBytes;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.previous !== undefined) {
            queryParameters['previous'] = requestParameters.previous;
        }

        if (requestParameters.sinceSeconds !== undefined) {
            queryParameters['sinceSeconds'] = requestParameters.sinceSeconds;
        }

        if (requestParameters.tailLines !== undefined) {
            queryParameters['tailLines'] = requestParameters.tailLines;
        }

        if (requestParameters.timestamps !== undefined) {
            queryParameters['timestamps'] = requestParameters.timestamps;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/log`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.TextApiResponse(response);
    }

    /**
     * read log of the specified Pod
     */
    async readCoreV1NamespacedPodLog(requestParameters: ReadCoreV1NamespacedPodLogRequest): Promise<string> {
        const response = await this.readCoreV1NamespacedPodLogRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Pod
     */
    async readCoreV1NamespacedPodStatusRaw(requestParameters: ReadCoreV1NamespacedPodStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPodStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * read status of the specified Pod
     */
    async readCoreV1NamespacedPodStatus(requestParameters: ReadCoreV1NamespacedPodStatusRequest): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.readCoreV1NamespacedPodStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified PodTemplate
     */
    async readCoreV1NamespacedPodTemplateRaw(requestParameters: ReadCoreV1NamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * read the specified PodTemplate
     */
    async readCoreV1NamespacedPodTemplate(requestParameters: ReadCoreV1NamespacedPodTemplateRequest): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.readCoreV1NamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerRaw(requestParameters: ReadCoreV1NamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationController(requestParameters: ReadCoreV1NamespacedReplicationControllerRequest): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.readCoreV1NamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerScaleRaw(requestParameters: ReadCoreV1NamespacedReplicationControllerScaleRequest): Promise<runtime.ApiResponse<IoK8sApiAutoscalingV1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedReplicationControllerScale.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiAutoscalingV1ScaleFromJSON(jsonValue));
    }

    /**
     * read scale of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerScale(requestParameters: ReadCoreV1NamespacedReplicationControllerScaleRequest): Promise<IoK8sApiAutoscalingV1Scale> {
        const response = await this.readCoreV1NamespacedReplicationControllerScaleRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerStatusRaw(requestParameters: ReadCoreV1NamespacedReplicationControllerStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedReplicationControllerStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * read status of the specified ReplicationController
     */
    async readCoreV1NamespacedReplicationControllerStatus(requestParameters: ReadCoreV1NamespacedReplicationControllerStatusRequest): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.readCoreV1NamespacedReplicationControllerStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuotaRaw(requestParameters: ReadCoreV1NamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuota(requestParameters: ReadCoreV1NamespacedResourceQuotaRequest): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.readCoreV1NamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuotaStatusRaw(requestParameters: ReadCoreV1NamespacedResourceQuotaStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedResourceQuotaStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * read status of the specified ResourceQuota
     */
    async readCoreV1NamespacedResourceQuotaStatus(requestParameters: ReadCoreV1NamespacedResourceQuotaStatusRequest): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.readCoreV1NamespacedResourceQuotaStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Secret
     */
    async readCoreV1NamespacedSecretRaw(requestParameters: ReadCoreV1NamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * read the specified Secret
     */
    async readCoreV1NamespacedSecret(requestParameters: ReadCoreV1NamespacedSecretRequest): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.readCoreV1NamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Service
     */
    async readCoreV1NamespacedServiceRaw(requestParameters: ReadCoreV1NamespacedServiceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * read the specified Service
     */
    async readCoreV1NamespacedService(requestParameters: ReadCoreV1NamespacedServiceRequest): Promise<IoK8sApiCoreV1Service> {
        const response = await this.readCoreV1NamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified ServiceAccount
     */
    async readCoreV1NamespacedServiceAccountRaw(requestParameters: ReadCoreV1NamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * read the specified ServiceAccount
     */
    async readCoreV1NamespacedServiceAccount(requestParameters: ReadCoreV1NamespacedServiceAccountRequest): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.readCoreV1NamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Service
     */
    async readCoreV1NamespacedServiceStatusRaw(requestParameters: ReadCoreV1NamespacedServiceStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling readCoreV1NamespacedServiceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * read status of the specified Service
     */
    async readCoreV1NamespacedServiceStatus(requestParameters: ReadCoreV1NamespacedServiceStatusRequest): Promise<IoK8sApiCoreV1Service> {
        const response = await this.readCoreV1NamespacedServiceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified Node
     */
    async readCoreV1NodeRaw(requestParameters: ReadCoreV1NodeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1Node.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * read the specified Node
     */
    async readCoreV1Node(requestParameters: ReadCoreV1NodeRequest): Promise<IoK8sApiCoreV1Node> {
        const response = await this.readCoreV1NodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified Node
     */
    async readCoreV1NodeStatusRaw(requestParameters: ReadCoreV1NodeStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1NodeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * read status of the specified Node
     */
    async readCoreV1NodeStatus(requestParameters: ReadCoreV1NodeStatusRequest): Promise<IoK8sApiCoreV1Node> {
        const response = await this.readCoreV1NodeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * read the specified PersistentVolume
     */
    async readCoreV1PersistentVolumeRaw(requestParameters: ReadCoreV1PersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1PersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.exact !== undefined) {
            queryParameters['exact'] = requestParameters.exact;
        }

        if (requestParameters._export !== undefined) {
            queryParameters['export'] = requestParameters._export;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read the specified PersistentVolume
     */
    async readCoreV1PersistentVolume(requestParameters: ReadCoreV1PersistentVolumeRequest): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.readCoreV1PersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readCoreV1PersistentVolumeStatusRaw(requestParameters: ReadCoreV1PersistentVolumeStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling readCoreV1PersistentVolumeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * read status of the specified PersistentVolume
     */
    async readCoreV1PersistentVolumeStatus(requestParameters: ReadCoreV1PersistentVolumeStatusRequest): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.readCoreV1PersistentVolumeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Namespace
     */
    async replaceCoreV1NamespaceRaw(requestParameters: ReplaceCoreV1NamespaceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1Namespace.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1Namespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace the specified Namespace
     */
    async replaceCoreV1Namespace(requestParameters: ReplaceCoreV1NamespaceRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.replaceCoreV1NamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceCoreV1NamespaceFinalizeRaw(requestParameters: ReplaceCoreV1NamespaceFinalizeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespaceFinalize.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespaceFinalize.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/finalize`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace finalize of the specified Namespace
     */
    async replaceCoreV1NamespaceFinalize(requestParameters: ReplaceCoreV1NamespaceFinalizeRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.replaceCoreV1NamespaceFinalizeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceCoreV1NamespaceStatusRaw(requestParameters: ReplaceCoreV1NamespaceStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Namespace>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespaceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespaceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NamespaceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NamespaceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Namespace
     */
    async replaceCoreV1NamespaceStatus(requestParameters: ReplaceCoreV1NamespaceStatusRequest): Promise<IoK8sApiCoreV1Namespace> {
        const response = await this.replaceCoreV1NamespaceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceCoreV1NamespacedConfigMapRaw(requestParameters: ReplaceCoreV1NamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ConfigMap>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ConfigMapToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ConfigMapFromJSON(jsonValue));
    }

    /**
     * replace the specified ConfigMap
     */
    async replaceCoreV1NamespacedConfigMap(requestParameters: ReplaceCoreV1NamespacedConfigMapRequest): Promise<IoK8sApiCoreV1ConfigMap> {
        const response = await this.replaceCoreV1NamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Endpoints
     */
    async replaceCoreV1NamespacedEndpointsRaw(requestParameters: ReplaceCoreV1NamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Endpoints>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EndpointsToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EndpointsFromJSON(jsonValue));
    }

    /**
     * replace the specified Endpoints
     */
    async replaceCoreV1NamespacedEndpoints(requestParameters: ReplaceCoreV1NamespacedEndpointsRequest): Promise<IoK8sApiCoreV1Endpoints> {
        const response = await this.replaceCoreV1NamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Event
     */
    async replaceCoreV1NamespacedEventRaw(requestParameters: ReplaceCoreV1NamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Event>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedEvent.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1EventToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1EventFromJSON(jsonValue));
    }

    /**
     * replace the specified Event
     */
    async replaceCoreV1NamespacedEvent(requestParameters: ReplaceCoreV1NamespacedEventRequest): Promise<IoK8sApiCoreV1Event> {
        const response = await this.replaceCoreV1NamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified LimitRange
     */
    async replaceCoreV1NamespacedLimitRangeRaw(requestParameters: ReplaceCoreV1NamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1LimitRange>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1LimitRangeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1LimitRangeFromJSON(jsonValue));
    }

    /**
     * replace the specified LimitRange
     */
    async replaceCoreV1NamespacedLimitRange(requestParameters: ReplaceCoreV1NamespacedLimitRangeRequest): Promise<IoK8sApiCoreV1LimitRange> {
        const response = await this.replaceCoreV1NamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeClaimToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaim(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.replaceCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolumeClaim>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPersistentVolumeClaimStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/persistentvolumeclaims/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeClaimToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeClaimFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolumeClaim
     */
    async replaceCoreV1NamespacedPersistentVolumeClaimStatus(requestParameters: ReplaceCoreV1NamespacedPersistentVolumeClaimStatusRequest): Promise<IoK8sApiCoreV1PersistentVolumeClaim> {
        const response = await this.replaceCoreV1NamespacedPersistentVolumeClaimStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Pod
     */
    async replaceCoreV1NamespacedPodRaw(requestParameters: ReplaceCoreV1NamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPod.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * replace the specified Pod
     */
    async replaceCoreV1NamespacedPod(requestParameters: ReplaceCoreV1NamespacedPodRequest): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.replaceCoreV1NamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Pod
     */
    async replaceCoreV1NamespacedPodStatusRaw(requestParameters: ReplaceCoreV1NamespacedPodStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Pod>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPodStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPodStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/pods/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Pod
     */
    async replaceCoreV1NamespacedPodStatus(requestParameters: ReplaceCoreV1NamespacedPodStatusRequest): Promise<IoK8sApiCoreV1Pod> {
        const response = await this.replaceCoreV1NamespacedPodStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceCoreV1NamespacedPodTemplateRaw(requestParameters: ReplaceCoreV1NamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PodTemplate>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PodTemplateToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PodTemplateFromJSON(jsonValue));
    }

    /**
     * replace the specified PodTemplate
     */
    async replaceCoreV1NamespacedPodTemplate(requestParameters: ReplaceCoreV1NamespacedPodTemplateRequest): Promise<IoK8sApiCoreV1PodTemplate> {
        const response = await this.replaceCoreV1NamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerRaw(requestParameters: ReplaceCoreV1NamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ReplicationControllerToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationController(requestParameters: ReplaceCoreV1NamespacedReplicationControllerRequest): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.replaceCoreV1NamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerScaleRaw(requestParameters: ReplaceCoreV1NamespacedReplicationControllerScaleRequest): Promise<runtime.ApiResponse<IoK8sApiAutoscalingV1Scale>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedReplicationControllerScale.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedReplicationControllerScale.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/scale`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiAutoscalingV1ScaleToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiAutoscalingV1ScaleFromJSON(jsonValue));
    }

    /**
     * replace scale of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerScale(requestParameters: ReplaceCoreV1NamespacedReplicationControllerScaleRequest): Promise<IoK8sApiAutoscalingV1Scale> {
        const response = await this.replaceCoreV1NamespacedReplicationControllerScaleRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerStatusRaw(requestParameters: ReplaceCoreV1NamespacedReplicationControllerStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ReplicationController>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedReplicationControllerStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedReplicationControllerStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/replicationcontrollers/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ReplicationControllerToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ReplicationControllerFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ReplicationController
     */
    async replaceCoreV1NamespacedReplicationControllerStatus(requestParameters: ReplaceCoreV1NamespacedReplicationControllerStatusRequest): Promise<IoK8sApiCoreV1ReplicationController> {
        const response = await this.replaceCoreV1NamespacedReplicationControllerStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuotaRaw(requestParameters: ReplaceCoreV1NamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ResourceQuotaToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuota(requestParameters: ReplaceCoreV1NamespacedResourceQuotaRequest): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.replaceCoreV1NamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuotaStatusRaw(requestParameters: ReplaceCoreV1NamespacedResourceQuotaStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ResourceQuota>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedResourceQuotaStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedResourceQuotaStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/resourcequotas/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ResourceQuotaToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ResourceQuotaFromJSON(jsonValue));
    }

    /**
     * replace status of the specified ResourceQuota
     */
    async replaceCoreV1NamespacedResourceQuotaStatus(requestParameters: ReplaceCoreV1NamespacedResourceQuotaStatusRequest): Promise<IoK8sApiCoreV1ResourceQuota> {
        const response = await this.replaceCoreV1NamespacedResourceQuotaStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Secret
     */
    async replaceCoreV1NamespacedSecretRaw(requestParameters: ReplaceCoreV1NamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Secret>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedSecret.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1SecretToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1SecretFromJSON(jsonValue));
    }

    /**
     * replace the specified Secret
     */
    async replaceCoreV1NamespacedSecret(requestParameters: ReplaceCoreV1NamespacedSecretRequest): Promise<IoK8sApiCoreV1Secret> {
        const response = await this.replaceCoreV1NamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Service
     */
    async replaceCoreV1NamespacedServiceRaw(requestParameters: ReplaceCoreV1NamespacedServiceRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedService.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * replace the specified Service
     */
    async replaceCoreV1NamespacedService(requestParameters: ReplaceCoreV1NamespacedServiceRequest): Promise<IoK8sApiCoreV1Service> {
        const response = await this.replaceCoreV1NamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceCoreV1NamespacedServiceAccountRaw(requestParameters: ReplaceCoreV1NamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1ServiceAccount>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceAccountToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceAccountFromJSON(jsonValue));
    }

    /**
     * replace the specified ServiceAccount
     */
    async replaceCoreV1NamespacedServiceAccount(requestParameters: ReplaceCoreV1NamespacedServiceAccountRequest): Promise<IoK8sApiCoreV1ServiceAccount> {
        const response = await this.replaceCoreV1NamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Service
     */
    async replaceCoreV1NamespacedServiceStatusRaw(requestParameters: ReplaceCoreV1NamespacedServiceStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Service>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling replaceCoreV1NamespacedServiceStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NamespacedServiceStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/namespaces/{namespace}/services/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1ServiceToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1ServiceFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Service
     */
    async replaceCoreV1NamespacedServiceStatus(requestParameters: ReplaceCoreV1NamespacedServiceStatusRequest): Promise<IoK8sApiCoreV1Service> {
        const response = await this.replaceCoreV1NamespacedServiceStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified Node
     */
    async replaceCoreV1NodeRaw(requestParameters: ReplaceCoreV1NodeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1Node.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1Node.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NodeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * replace the specified Node
     */
    async replaceCoreV1Node(requestParameters: ReplaceCoreV1NodeRequest): Promise<IoK8sApiCoreV1Node> {
        const response = await this.replaceCoreV1NodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified Node
     */
    async replaceCoreV1NodeStatusRaw(requestParameters: ReplaceCoreV1NodeStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1Node>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1NodeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1NodeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/nodes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1NodeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1NodeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified Node
     */
    async replaceCoreV1NodeStatus(requestParameters: ReplaceCoreV1NodeStatusRequest): Promise<IoK8sApiCoreV1Node> {
        const response = await this.replaceCoreV1NodeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolumeRaw(requestParameters: ReplaceCoreV1PersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1PersistentVolume.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1PersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolume(requestParameters: ReplaceCoreV1PersistentVolumeRequest): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.replaceCoreV1PersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolumeStatusRaw(requestParameters: ReplaceCoreV1PersistentVolumeStatusRequest): Promise<runtime.ApiResponse<IoK8sApiCoreV1PersistentVolume>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling replaceCoreV1PersistentVolumeStatus.');
        }

        if (requestParameters.body === null || requestParameters.body === undefined) {
            throw new runtime.RequiredError('body','Required parameter requestParameters.body was null or undefined when calling replaceCoreV1PersistentVolumeStatus.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.dryRun !== undefined) {
            queryParameters['dryRun'] = requestParameters.dryRun;
        }

        if (requestParameters.fieldManager !== undefined) {
            queryParameters['fieldManager'] = requestParameters.fieldManager;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/persistentvolumes/{name}/status`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IoK8sApiCoreV1PersistentVolumeToJSON(requestParameters.body),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApiCoreV1PersistentVolumeFromJSON(jsonValue));
    }

    /**
     * replace status of the specified PersistentVolume
     */
    async replaceCoreV1PersistentVolumeStatus(requestParameters: ReplaceCoreV1PersistentVolumeStatusRequest): Promise<IoK8sApiCoreV1PersistentVolume> {
        const response = await this.replaceCoreV1PersistentVolumeStatusRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ConfigMapListForAllNamespacesRaw(requestParameters: WatchCoreV1ConfigMapListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/configmaps`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ConfigMapListForAllNamespaces(requestParameters: WatchCoreV1ConfigMapListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ConfigMapListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EndpointsListForAllNamespacesRaw(requestParameters: WatchCoreV1EndpointsListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/endpoints`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EndpointsListForAllNamespaces(requestParameters: WatchCoreV1EndpointsListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1EndpointsListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EventListForAllNamespacesRaw(requestParameters: WatchCoreV1EventListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/events`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1EventListForAllNamespaces(requestParameters: WatchCoreV1EventListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1EventListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1LimitRangeListForAllNamespacesRaw(requestParameters: WatchCoreV1LimitRangeListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/limitranges`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1LimitRangeListForAllNamespaces(requestParameters: WatchCoreV1LimitRangeListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1LimitRangeListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Namespace. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespaceRaw(requestParameters: WatchCoreV1NamespaceRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1Namespace.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Namespace. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1Namespace(requestParameters: WatchCoreV1NamespaceRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespaceRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Namespace. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespaceListRaw(requestParameters: WatchCoreV1NamespaceListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Namespace. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespaceList(requestParameters: WatchCoreV1NamespaceListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespaceListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedConfigMapRaw(requestParameters: WatchCoreV1NamespacedConfigMapRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedConfigMap.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedConfigMap.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/configmaps/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedConfigMap(requestParameters: WatchCoreV1NamespacedConfigMapRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedConfigMapRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedConfigMapListRaw(requestParameters: WatchCoreV1NamespacedConfigMapListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedConfigMapList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/configmaps`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ConfigMap. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedConfigMapList(requestParameters: WatchCoreV1NamespacedConfigMapListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedConfigMapListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Endpoints. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEndpointsRaw(requestParameters: WatchCoreV1NamespacedEndpointsRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedEndpoints.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEndpoints.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/endpoints/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Endpoints. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEndpoints(requestParameters: WatchCoreV1NamespacedEndpointsRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEndpointsRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEndpointsListRaw(requestParameters: WatchCoreV1NamespacedEndpointsListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEndpointsList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/endpoints`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Endpoints. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEndpointsList(requestParameters: WatchCoreV1NamespacedEndpointsListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEndpointsListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Event. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEventRaw(requestParameters: WatchCoreV1NamespacedEventRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedEvent.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEvent.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/events/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Event. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedEvent(requestParameters: WatchCoreV1NamespacedEventRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEventRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEventListRaw(requestParameters: WatchCoreV1NamespacedEventListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedEventList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/events`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Event. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedEventList(requestParameters: WatchCoreV1NamespacedEventListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedEventListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind LimitRange. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedLimitRangeRaw(requestParameters: WatchCoreV1NamespacedLimitRangeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedLimitRange.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedLimitRange.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/limitranges/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind LimitRange. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedLimitRange(requestParameters: WatchCoreV1NamespacedLimitRangeRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedLimitRangeRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedLimitRangeListRaw(requestParameters: WatchCoreV1NamespacedLimitRangeListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedLimitRangeList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/limitranges`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of LimitRange. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedLimitRangeList(requestParameters: WatchCoreV1NamespacedLimitRangeListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedLimitRangeListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedPersistentVolumeClaim.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPersistentVolumeClaim.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPersistentVolumeClaim(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPersistentVolumeClaimRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPersistentVolumeClaimListRaw(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPersistentVolumeClaimList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/persistentvolumeclaims`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPersistentVolumeClaimList(requestParameters: WatchCoreV1NamespacedPersistentVolumeClaimListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPersistentVolumeClaimListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Pod. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPodRaw(requestParameters: WatchCoreV1NamespacedPodRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedPod.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPod.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/pods/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Pod. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPod(requestParameters: WatchCoreV1NamespacedPodRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodListRaw(requestParameters: WatchCoreV1NamespacedPodListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPodList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/pods`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodList(requestParameters: WatchCoreV1NamespacedPodListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPodTemplateRaw(requestParameters: WatchCoreV1NamespacedPodTemplateRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedPodTemplate.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPodTemplate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/podtemplates/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedPodTemplate(requestParameters: WatchCoreV1NamespacedPodTemplateRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodTemplateRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodTemplateListRaw(requestParameters: WatchCoreV1NamespacedPodTemplateListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedPodTemplateList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/podtemplates`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedPodTemplateList(requestParameters: WatchCoreV1NamespacedPodTemplateListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedPodTemplateListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedReplicationControllerRaw(requestParameters: WatchCoreV1NamespacedReplicationControllerRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedReplicationController.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedReplicationController.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/replicationcontrollers/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedReplicationController(requestParameters: WatchCoreV1NamespacedReplicationControllerRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedReplicationControllerRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedReplicationControllerListRaw(requestParameters: WatchCoreV1NamespacedReplicationControllerListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedReplicationControllerList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/replicationcontrollers`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedReplicationControllerList(requestParameters: WatchCoreV1NamespacedReplicationControllerListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedReplicationControllerListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedResourceQuotaRaw(requestParameters: WatchCoreV1NamespacedResourceQuotaRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedResourceQuota.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedResourceQuota.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/resourcequotas/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedResourceQuota(requestParameters: WatchCoreV1NamespacedResourceQuotaRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedResourceQuotaRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedResourceQuotaListRaw(requestParameters: WatchCoreV1NamespacedResourceQuotaListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedResourceQuotaList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/resourcequotas`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedResourceQuotaList(requestParameters: WatchCoreV1NamespacedResourceQuotaListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedResourceQuotaListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Secret. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedSecretRaw(requestParameters: WatchCoreV1NamespacedSecretRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedSecret.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedSecret.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/secrets/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Secret. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedSecret(requestParameters: WatchCoreV1NamespacedSecretRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedSecretRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedSecretListRaw(requestParameters: WatchCoreV1NamespacedSecretListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedSecretList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/secrets`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedSecretList(requestParameters: WatchCoreV1NamespacedSecretListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedSecretListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Service. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedServiceRaw(requestParameters: WatchCoreV1NamespacedServiceRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedService.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedService.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/services/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Service. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedService(requestParameters: WatchCoreV1NamespacedServiceRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedServiceAccountRaw(requestParameters: WatchCoreV1NamespacedServiceAccountRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1NamespacedServiceAccount.');
        }

        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedServiceAccount.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/serviceaccounts/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))).replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NamespacedServiceAccount(requestParameters: WatchCoreV1NamespacedServiceAccountRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceAccountRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceAccountListRaw(requestParameters: WatchCoreV1NamespacedServiceAccountListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedServiceAccountList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/serviceaccounts`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceAccountList(requestParameters: WatchCoreV1NamespacedServiceAccountListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceAccountListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceListRaw(requestParameters: WatchCoreV1NamespacedServiceListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.namespace === null || requestParameters.namespace === undefined) {
            throw new runtime.RequiredError('namespace','Required parameter requestParameters.namespace was null or undefined when calling watchCoreV1NamespacedServiceList.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/namespaces/{namespace}/services`.replace(`{${"namespace"}}`, encodeURIComponent(String(requestParameters.namespace))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NamespacedServiceList(requestParameters: WatchCoreV1NamespacedServiceListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NamespacedServiceListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind Node. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1NodeRaw(requestParameters: WatchCoreV1NodeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1Node.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/nodes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind Node. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1Node(requestParameters: WatchCoreV1NodeRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NodeRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Node. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NodeListRaw(requestParameters: WatchCoreV1NodeListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/nodes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Node. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1NodeList(requestParameters: WatchCoreV1NodeListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1NodeListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch changes to an object of kind PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1PersistentVolumeRaw(requestParameters: WatchCoreV1PersistentVolumeRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling watchCoreV1PersistentVolume.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/persistentvolumes/{name}`.replace(`{${"name"}}`, encodeURIComponent(String(requestParameters.name))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch changes to an object of kind PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead, filtered to a single item with the \'fieldSelector\' parameter.
     */
    async watchCoreV1PersistentVolume(requestParameters: WatchCoreV1PersistentVolumeRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PersistentVolumeRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeClaimListForAllNamespacesRaw(requestParameters: WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/persistentvolumeclaims`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PersistentVolumeClaim. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeClaimListForAllNamespaces(requestParameters: WatchCoreV1PersistentVolumeClaimListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PersistentVolumeClaimListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeListRaw(requestParameters: WatchCoreV1PersistentVolumeListRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/persistentvolumes`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PersistentVolume. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PersistentVolumeList(requestParameters: WatchCoreV1PersistentVolumeListRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PersistentVolumeListRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodListForAllNamespacesRaw(requestParameters: WatchCoreV1PodListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/pods`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Pod. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodListForAllNamespaces(requestParameters: WatchCoreV1PodListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PodListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodTemplateListForAllNamespacesRaw(requestParameters: WatchCoreV1PodTemplateListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/podtemplates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of PodTemplate. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1PodTemplateListForAllNamespaces(requestParameters: WatchCoreV1PodTemplateListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1PodTemplateListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ReplicationControllerListForAllNamespacesRaw(requestParameters: WatchCoreV1ReplicationControllerListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/replicationcontrollers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ReplicationController. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ReplicationControllerListForAllNamespaces(requestParameters: WatchCoreV1ReplicationControllerListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ReplicationControllerListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ResourceQuotaListForAllNamespacesRaw(requestParameters: WatchCoreV1ResourceQuotaListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/resourcequotas`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ResourceQuota. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ResourceQuotaListForAllNamespaces(requestParameters: WatchCoreV1ResourceQuotaListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ResourceQuotaListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1SecretListForAllNamespacesRaw(requestParameters: WatchCoreV1SecretListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/secrets`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Secret. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1SecretListForAllNamespaces(requestParameters: WatchCoreV1SecretListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1SecretListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceAccountListForAllNamespacesRaw(requestParameters: WatchCoreV1ServiceAccountListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/serviceaccounts`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of ServiceAccount. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceAccountListForAllNamespaces(requestParameters: WatchCoreV1ServiceAccountListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ServiceAccountListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceListForAllNamespacesRaw(requestParameters: WatchCoreV1ServiceListForAllNamespacesRequest): Promise<runtime.ApiResponse<IoK8sApimachineryPkgApisMetaV1WatchEvent>> {
        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.allowWatchBookmarks !== undefined) {
            queryParameters['allowWatchBookmarks'] = requestParameters.allowWatchBookmarks;
        }

        if (requestParameters._continue !== undefined) {
            queryParameters['continue'] = requestParameters._continue;
        }

        if (requestParameters.fieldSelector !== undefined) {
            queryParameters['fieldSelector'] = requestParameters.fieldSelector;
        }

        if (requestParameters.labelSelector !== undefined) {
            queryParameters['labelSelector'] = requestParameters.labelSelector;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.pretty !== undefined) {
            queryParameters['pretty'] = requestParameters.pretty;
        }

        if (requestParameters.resourceVersion !== undefined) {
            queryParameters['resourceVersion'] = requestParameters.resourceVersion;
        }

        if (requestParameters.timeoutSeconds !== undefined) {
            queryParameters['timeoutSeconds'] = requestParameters.timeoutSeconds;
        }

        if (requestParameters.watch !== undefined) {
            queryParameters['watch'] = requestParameters.watch;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["authorization"] = this.configuration.apiKey("authorization"); // BearerToken authentication
        }

        const response = await this.request({
            path: `/api/v1/watch/services`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IoK8sApimachineryPkgApisMetaV1WatchEventFromJSON(jsonValue));
    }

    /**
     * watch individual changes to a list of Service. deprecated: use the \'watch\' parameter with a list operation instead.
     */
    async watchCoreV1ServiceListForAllNamespaces(requestParameters: WatchCoreV1ServiceListForAllNamespacesRequest): Promise<IoK8sApimachineryPkgApisMetaV1WatchEvent> {
        const response = await this.watchCoreV1ServiceListForAllNamespacesRaw(requestParameters);
        return await response.value();
    }

}
